## 内存分配与释放设计

### 1. 目的
 
此次的内存设计是针对WASM虚拟机在执行过程中申请内存和释放内存。由于现有的内存分配规则是从给定的内存地址开始一直向后分配，对于前面释放的内存不能进行再次利用，因此对内存的利用率不高，导致内存浪费。 此次设计采用伙伴算法的规则优化内存分配和回收过程，达到能快速分配内存并回收再利用的目的。

### 2. 设计过程

整体设计思想是，通过一个数组形式的完全二叉树来监控管理内存，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。如图所示，假设总大小为16单位的内存，我们就建立一个深度为5的满二叉树，根节点从数组下标[0]开始，监控大小16的块；它的左右孩子节点下标[1~2]，监控大小8的块；第三层节点下标[3~6]监控大小4的块……依此类推。


<div align=center>
<img src="https://github.com/Noyawei/memory-alloc/raw/master/image/buddy.jpg" width = "700" height = "450" alt="内存变化"/>
<p>链表拆分合并框图</p>
</div>



在分配阶段，首先要搜索大小适配的块，假设第一次分配3，转换成2的幂是4，我们先要对整个内存进行对半切割，从16切割到4需要两步，那么从下标[0]节点开始深度搜索到下标[3]的节点并将其标记为已分配。第二次再分配3那么就标记下标[4]的节点。第三次分配6，即大小为8，那么搜索下标[2]的节点，因为下标[1]所对应的块被下标[3~4]占用了。

在释放阶段，我们依次释放上述第一次和第二次分配的块，即先释放[3]再释放[4]，当释放下标[4]节点后，我们发现之前释放的[3]是相邻的，于是我们立马将这两个节点进行合并，这样一来下次分配大小8的时候，我们就可以搜索到下标[1]适配了。若进一步释放下标[2]，同[1]合并后整个内存就回归到初始状态。

###2. 算法实现

代码实现，首先是伙伴分配器的数据结构

	type Memory struct {
		Memory []byte
		Start  int //start position for malloc
		Size   int //memory size for malloc
		tree   []int
	}

这里的成员size表明用于分配的内存大小，Start为内存分配的起始位置，tree就是二叉树的节点标记，表明所对应的内存块的空闲大小，整个tree的长度为满二叉树节点数目。初始化内存后，若Size=16，则初始化后的tree=[16 8 8 4 4 4 4 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]

**分配逻辑：**

假设分配size=3字节：

1. 将size调整到3的幂大小size=4，并检查是否超过可分配的内存限度;
2. 在tree中从index=0开始向后查找，直到找到节点大小nodeSize=4的节点索引index=3，将该节点nodeSize标记为0,计算该节点对应的内存地址offset=(3+1)*4-16=0，此时tree=[16 8 8 0 4 4 4 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
3. 因为小块内存被占用，大块就不能分配了，比如index=3标记为0分离出来，那么其父节点下标[0]、[1]也需要相应大小的分离。将它们的nodeSize进行折扣计算，取左右子树较大值，修改之后tree=[8 4 8 0 4 4 4 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
4. 将offset加上内存分配的起始地址m.Start，返回。

**释放逻辑：**

假设释放上面分配的内存offset=0+m.Start:

1. 将传入的offset减去内存分配起始位置offset=0，并检查内存offset合理性；
2. 通过offset计算得到对应最下层nodeSize=1的节点索引index=0+16-1=15,从index=15向上查找知道父节点nodeSize=0的索引，即当初分配块所适配的大小和位置，恢复该节点的nodeSize,清空内存数据；
3. 继续向上回溯，检查是否存在合并的块，依据就是左右子树nodeSize的值相加是否等于原空闲块满状态的大小，如果能够合并，就将父节点nodeSize标记为相加的和。





